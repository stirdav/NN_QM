#= Remember to create a symbol identifying your problme, and update the dictionaries

1. dataset_problems_dictionary
2. plot_problem_dictionary

in the file ML_QM_library.jl
=#

##################################################
#= Physical parameters, variables, operators =#
##################################################
#ω = ...
#...


#basis = ...
#QM_system1 = ho(...)
#QM_system2 = ho(...)
#....


################################################################
################################################################
#= FUNCTIONS TO GENERATE THE DATASET FOR THE XXXXXX PROBLEM =#
################################################################
#=
function XXXXX_NN_outputs(p, parameters_range, dim_parameters_space, n_samples)  #ok
    ...

    return Vector{Vector{Floats}} containing the sampled drives, being the NN outputs
end

function XXXX_NN_inputs(t0, initial_state, dataset_features, pulse_parameters, n_samples, typeofdynamics) #Typeofdynamics contains [:corrected]
    inputs = Vector{Vector{Float64}}(undef, n_samples) #exit vector


    return Vector{Vector{Floats}} containing the states generated by the sampled drives (expressed on some matrix basis)

end


function XXXXX_dynamics(t0, initial_state, pulse_parameters, typeofdynamics, problem_features, modeofdynamics) #mode_vector -> [typeofcorrection, n_phonon, :dynamics]
    ... = pulse_parameters
    dt = 1e-6; #dt of time integration

    typeofcorrection, n_phonon = problem_features.correction, problem_features.phonon_n

    # Pre-define the function, avoid scoping issues
    Hamiltonian, dissipation, dissipation_d = create_XXXXX_dynamics(t0, pulse_parameters, typeofcorrection, n_phonon)
    dynamics_input = nothing

    #Here, we discriminate between dissipative and unitary dynamics
    if typeofdynamics == :master || typeofdynamics == :master_dynamic #to be fixed
        dynamics_input = (t, ψ) -> (Hamiltonian(t, ψ), dissipation, dissipation_d)

        #evolution 
        ... 


        if modeofdynamics == :dynamics
            return ....
        elseif modeofdynamics == :final_state
            return ....
        elseif modeofdynamics == :all_dynamics
            return ....
        else
            return ....
        end

    else #outputs are kets
        dynamics_input = (t, ψ) -> Hamiltonian(t, ψ)

        #evolution 
        ...

        
        if modeofdynamics == :dynamics
            return ...
        elseif modeofdynamics == :final_state
            return ...
        elseif modeofdynamics == :all_dynamics
            return ...
        else
            return ...
        end

    end
    
end


#= generates [Hamiltonian, Lindblad operator and its hermitian conjugate]  =#
function create_FLstep_dynamics(t0, pulse_parameters, typeofcorrection, n_phonon)
    ... = pulse_parameters

    if typeofcorrection == :correction_on
        ...

    else
        ...
    end

    #Time indipendent Hamiltonian
    H0 = ...

    #Time dependent functions
    ...

    Ht = LazySum(...)
    function Hamiltonian(t, ψ)
        Ht.factors[1] = ...
        Ht.factors[2] = ...
        ...
        return H0 + Ht
    end
    
    return [
    Hamiltonian, 
    diss,
    dagger.(diss)
    ]
end

=#
